"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./hooks/useSupabaseData.ts":
/*!**********************************!*\
  !*** ./hooks/useSupabaseData.ts ***!
  \**********************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useSupabaseData: function() { return /* binding */ useSupabaseData; }\n/* harmony export */ });\n/* harmony import */ var _lib_supabase__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @/lib/supabase */ \"(app-pages-browser)/./lib/supabase.ts\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n\n\nfunction useSupabaseData(user) {\n    // Caches for songs and liked songs to avoid repeated cloud fetches\n    const songsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const likedSongsCache = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    const [songs, setSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Personalized songs state (smart sorted, filtered, and history-excluded)\n    const [personalizedSongs, setPersonalizedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    // Trending songs state (top 15 by views+likes)\n    const [trendingSongs, setTrendingSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [playlists, setPlaylists] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [likedSongs, setLikedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(new Set());\n    const [lastPlayedSong, setLastPlayedSong] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const [recentlyPlayedSongs, setRecentlyPlayedSongs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [loading, setLoading] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(true);\n    const [currentSongStartTime, setCurrentSongStartTime] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(null);\n    const currentSongRef = (0,react__WEBPACK_IMPORTED_MODULE_1__.useRef)(null);\n    // Get personalized songs based on user's actual listening preferences\n    const getSmartPersonalizedSongs = async (userId, listenedSongsInBatch, excludeSongs)=>{\n        try {\n            var _listenedSongsInBatch_;\n            console.log(\"\\uD83E\\uDDE0 Fetching smart personalized songs based on listening behavior\");\n            console.log(\"\\uD83C\\uDFB5 Songs user actually listened to:\", listenedSongsInBatch.map((s)=>s.name));\n            if (listenedSongsInBatch.length === 0) {\n                console.log(\"⚠️ No listened songs in batch, falling back to regular personalization\");\n                return [];\n            }\n            // Extract tags and artists from listened songs\n            const preferredTags = new Set();\n            const preferredArtists = new Set();\n            listenedSongsInBatch.forEach((song)=>{\n                var _song_tags;\n                (_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.forEach((tag)=>preferredTags.add(tag.toLowerCase()));\n                preferredArtists.add(song.artist.toLowerCase());\n            });\n            console.log(\"\\uD83C\\uDFF7️ Preferred tags:\", Array.from(preferredTags));\n            console.log(\"\\uD83C\\uDFA4 Preferred artists:\", Array.from(preferredArtists));\n            // Use cache if available, otherwise fetch and cache\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for smart personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // Filter and score songs based on listening preferences and language\n            // Use the language of the first listened song as the filter\n            const languageFilter = (_listenedSongsInBatch_ = listenedSongsInBatch[0]) === null || _listenedSongsInBatch_ === void 0 ? void 0 : _listenedSongsInBatch_.language;\n            const availableSongs = songsData.filter((song)=>{\n                return !excludeSongs.has(song.file_id.toString()) && song.language === languageFilter;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs for smart recommendations (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // Score songs based on user's listening preferences\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // High priority: Tag matching with listened songs\n                const songTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.map((tag)=>tag.toLowerCase())) || [];\n                const matchingTags = songTags.filter((tag)=>preferredTags.has(tag));\n                score += matchingTags.length * 25; // Higher weight for tag matching\n                // High priority: Artist matching with listened songs\n                if (preferredArtists.has(song.artist.toLowerCase())) {\n                    score += 30; // Higher weight for artist matching\n                }\n                // Medium priority: Same language as listened songs\n                const listenedLanguages = listenedSongsInBatch.map((s)=>s.language);\n                if (listenedLanguages.includes(song.language)) {\n                    score += 15;\n                }\n                // Lower priority: General popularity\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Bonus for liked songs\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 10;\n                }\n                // Add small randomness to avoid repetition\n                score += Math.random() * 2;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 15) // Get more songs for variety\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83E\\uDDE0 Smart recommendations based on listening behavior:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getSmartPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Convert database song to UI song format\n    const convertDatabaseSong = function(dbSong) {\n        let isLiked = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n        return {\n            file_id: dbSong.file_id,\n            img_id: dbSong.img_id,\n            name: dbSong.name,\n            artist: dbSong.artist,\n            language: dbSong.language,\n            tags: dbSong.tags,\n            views: dbSong.views,\n            likes: dbSong.likes,\n            id: dbSong.file_id.toString(),\n            image: \"https://images.pexels.com/photos/\".concat(dbSong.img_id, \"/pexels-photo-\").concat(dbSong.img_id, \".jpeg?auto=compress&cs=tinysrgb&w=300\"),\n            isLiked\n        };\n    };\n    // Fetch all songs\n    const fetchSongs = async ()=>{\n        if (!user) {\n            setSongs([]);\n            return;\n        }\n        try {\n            console.log(\"Fetching all songs from supabase...\");\n            const { data: songsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\").order(\"views\", {\n                ascending: false\n            });\n            if (error) throw error;\n            console.log(\"Fetched songs:\", songsData === null || songsData === void 0 ? void 0 : songsData.length);\n            // Fetch liked songs\n            let userLikedSongs = new Set();\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n            if (likedData) {\n                userLikedSongs = new Set(likedData.map((item)=>item.song_id));\n                setLikedSongs(userLikedSongs);\n            }\n            // Fetch user history (for minutes_listened)\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened, songs(*)\").eq(\"user_id\", user.id).order(\"minutes_listened\", {\n                ascending: false\n            });\n            if (historyError) throw historyError;\n            console.log(\"Fetched user history:\", historyData === null || historyData === void 0 ? void 0 : historyData.length);\n            // Get top 15 most listened songs from history\n            const topHistory = (historyData || []).slice(0, 15).filter((h)=>h.songs);\n            // Collect tags and artists from top 15\n            const tagCount = {};\n            const artistCount = {};\n            topHistory.forEach((h)=>{\n                // h.songs may be an array or object, use first if array\n                const songObj = Array.isArray(h.songs) ? h.songs[0] : h.songs;\n                ((songObj === null || songObj === void 0 ? void 0 : songObj.tags) || []).forEach((tag)=>{\n                    const t = tag.toLowerCase();\n                    tagCount[t] = (tagCount[t] || 0) + 1;\n                });\n                if (songObj === null || songObj === void 0 ? void 0 : songObj.artist) {\n                    const a = songObj.artist.toLowerCase();\n                    artistCount[a] = (artistCount[a] || 0) + 1;\n                }\n            });\n            // Find most common tags and artists\n            const commonTags = Object.entries(tagCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [tag] = param;\n                return tag;\n            });\n            const commonArtists = Object.entries(artistCount).sort((a, b)=>b[1] - a[1]).slice(0, 5).map((param)=>{\n                let [artist] = param;\n                return artist;\n            });\n            console.log(\"Found similar tags:\", commonTags);\n            console.log(\"Found similar artists:\", commonArtists);\n            // Songs in history (to exclude for smart sort)\n            const historySongIds = new Set((historyData || []).map((h)=>{\n                var _h_song_id;\n                return (_h_song_id = h.song_id) === null || _h_song_id === void 0 ? void 0 : _h_song_id.toString();\n            }));\n            // Convert all songs\n            const convertedSongs = (songsData === null || songsData === void 0 ? void 0 : songsData.map((song)=>convertDatabaseSong(song, userLikedSongs.has(song.file_id)))) || [];\n            setSongs(convertedSongs); // songs is now all songs, not personalized\n            // Filter out songs in history for personalized sort\n            const filteredSongs = convertedSongs.filter((song)=>!historySongIds.has(song.id));\n            // Score songs by tag/artist match\n            const scoredSongs = filteredSongs.map((song)=>{\n                let score = 0;\n                // Tag match\n                const songTags = (song.tags || []).map((t)=>t.toLowerCase());\n                score += songTags.filter((t)=>commonTags.includes(t)).length * 10;\n                // Artist match\n                if (song.artist && commonArtists.includes(song.artist.toLowerCase())) {\n                    score += 20;\n                }\n                // Popularity\n                score += (song.views || 0) + (song.likes || 0);\n                return {\n                    song,\n                    score\n                };\n            });\n            // Sort by score descending\n            const personalizedSorted = scoredSongs.sort((a, b)=>b.score - a.score).map((s)=>s.song);\n            setPersonalizedSongs(personalizedSorted);\n            // Trending: top 15 by views+likes (from all songs, including history)\n            const trending = [\n                ...convertedSongs\n            ].sort((a, b)=>b.views + b.likes - (a.views + a.likes)).slice(0, 15);\n            setTrendingSongs(trending);\n            console.log(\"Trending songs:\", trending.map((s)=>\"\".concat(s.name, \" (\").concat(s.views, \" views, \").concat(s.likes, \" likes)\")));\n            // Set last played song as before\n            const { data: userData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").select(\"last_song_file_id\").eq(\"id\", user.id).single();\n            if (userData === null || userData === void 0 ? void 0 : userData.last_song_file_id) {\n                const lastSong = convertedSongs.find((song)=>song.file_id === userData.last_song_file_id);\n                if (lastSong) {\n                    setLastPlayedSong(lastSong);\n                }\n            }\n        } catch (error) {\n            console.error(\"Error fetching songs:\", error);\n            setSongs([]);\n        }\n    };\n    // Get personalized songs with proper error handling and filtering\n    const getPersonalizedSongs = async (userId, currentSong, listenedSongs)=>{\n        try {\n            console.log(\"\\uD83C\\uDFB5 Fetching personalized songs for:\", currentSong.name);\n            console.log(\"\\uD83C\\uDFB5 Listened songs count:\", (listenedSongs === null || listenedSongs === void 0 ? void 0 : listenedSongs.size) || 0);\n            // 1. Fetch all songs from cache or cloud\n            let songsData = songsCache.current;\n            if (!songsData) {\n                const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"songs\").select(\"*\");\n                if (error) {\n                    console.error(\"❌ Error fetching songs for personalization:\", error);\n                    return [];\n                }\n                if (!data || data.length === 0) {\n                    console.warn(\"⚠️ No songs found in database\");\n                    return [];\n                }\n                songsData = data;\n                songsCache.current = data;\n            }\n            // 2. Fetch user's listening history (not cached, as it may change frequently)\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"song_id, minutes_listened\").eq(\"user_id\", userId);\n            if (historyError) {\n                console.error(\"❌ Error fetching history:\", historyError);\n            }\n            const historyMap = new Map();\n            if (historyData) {\n                historyData.forEach((h)=>historyMap.set(h.song_id, h.minutes_listened || 0));\n            }\n            // 3. Get user's liked songs from cache or cloud\n            let userLikedSongs = likedSongsCache.current;\n            if (!userLikedSongs) {\n                const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", userId);\n                userLikedSongs = new Set();\n                if (likedData) {\n                    likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n                }\n                likedSongsCache.current = userLikedSongs;\n            }\n            // 4. Filter and score songs (add language filter)\n            const languageFilter = currentSong.language;\n            const availableSongs = songsData.filter((song)=>{\n                // Exclude current song\n                if (song.file_id === currentSong.file_id) {\n                    return false;\n                }\n                // Exclude listened songs if provided\n                if (listenedSongs && listenedSongs.has(song.file_id.toString())) {\n                    console.log(\"\\uD83D\\uDEAB Excluding listened song: \".concat(song.name, \" by \").concat(song.artist));\n                    return false;\n                }\n                // Only include songs with the same language as current song\n                if (song.language !== languageFilter) {\n                    return false;\n                }\n                return true;\n            });\n            console.log(\"\\uD83C\\uDFB5 Available songs after filtering (language: \".concat(languageFilter, \"): \").concat(availableSongs.length));\n            if (availableSongs.length === 0) {\n                console.warn(\"⚠️ No available songs after filtering\");\n                return [];\n            }\n            // 5. Score and sort songs\n            const scoredSongs = availableSongs.map((song)=>{\n                var _song_tags;\n                let score = 0;\n                // Tag matching (highest priority)\n                const matchingTags = ((_song_tags = song.tags) === null || _song_tags === void 0 ? void 0 : _song_tags.filter((tag)=>{\n                    var _currentSong_tags;\n                    return (_currentSong_tags = currentSong.tags) === null || _currentSong_tags === void 0 ? void 0 : _currentSong_tags.includes(tag);\n                })) || [];\n                score += matchingTags.length * 15;\n                // Artist matching\n                if (song.artist === currentSong.artist) {\n                    score += 25;\n                }\n                // Language matching\n                if (song.language === currentSong.language) {\n                    score += 10;\n                }\n                // Listening history boost\n                const listenedMinutes = historyMap.get(song.file_id) || 0;\n                score += Math.min(listenedMinutes * 2, 20); // Cap at 20 points\n                // Popularity boost (likes and views)\n                score += Math.log(1 + (song.likes || 0)) * 2;\n                score += Math.log(1 + (song.views || 0)) * 1;\n                // Liked songs boost\n                if (userLikedSongs.has(song.file_id)) {\n                    score += 8;\n                }\n                // Add controlled randomness to avoid repetition\n                score += Math.random() * 3;\n                return {\n                    song: convertDatabaseSong(song, userLikedSongs.has(song.file_id)),\n                    score\n                };\n            });\n            // 6. Sort by score and return top recommendations\n            const recommendations = scoredSongs.sort((a, b)=>b.score - a.score).slice(0, 10) // Get more songs to have a buffer\n            .map((entry)=>entry.song);\n            console.log(\"\\uD83C\\uDFB5 Personalized recommendations:\", recommendations.slice(0, 5).map((s)=>\"\".concat(s.name, \" by \").concat(s.artist)));\n            console.log(\"\\uD83C\\uDFB5 Total available songs:\", availableSongs.length);\n            return recommendations;\n        } catch (error) {\n            console.error(\"❌ Error in getPersonalizedSongs:\", error);\n            return [];\n        }\n    };\n    // Fetch recently played songs based on listening history\n    const fetchRecentlyPlayed = async ()=>{\n        if (!user) {\n            setRecentlyPlayedSongs([]);\n            return;\n        }\n        try {\n            // Get user's listening history sorted by minutes listened\n            const { data: historyData, error: historyError } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"history\").select(\"\\n          song_id,\\n          minutes_listened,\\n          songs (*)\\n        \").eq(\"user_id\", user.id).order(\"minutes_listened\", {\n                ascending: false\n            }).limit(9);\n            if (historyError) {\n                console.error(\"Error fetching recently played:\", historyError);\n                return;\n            }\n            if (!historyData || historyData.length === 0) {\n                setRecentlyPlayedSongs([]);\n                return;\n            }\n            // Get user's liked songs for proper conversion\n            const { data: likedData } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").select(\"song_id\").eq(\"user_id\", user.id);\n            const userLikedSongs = new Set();\n            if (likedData) {\n                likedData.forEach((item)=>userLikedSongs.add(item.song_id));\n            }\n            // Convert to Song format\n            const recentSongs = historyData.filter((item)=>item.songs) // Ensure song data exists\n            .map((item)=>{\n                const songObj = Array.isArray(item.songs) ? item.songs[0] : item.songs;\n                return convertDatabaseSong(songObj, userLikedSongs.has(item.song_id));\n            });\n            setRecentlyPlayedSongs(recentSongs);\n        } catch (error) {\n            console.error(\"Error fetching recently played songs:\", error);\n            setRecentlyPlayedSongs([]);\n        }\n    };\n    // Fetch user playlists\n    const fetchPlaylists = async ()=>{\n        if (!user) {\n            setPlaylists([]);\n            return;\n        }\n        try {\n            const { data: playlistsData, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").select(\"\\n          id,\\n          name,\\n          playlist_songs (\\n            songs (*)\\n          )\\n        \").eq(\"user_id\", user.id);\n            if (error) throw error;\n            const convertedPlaylists = (playlistsData === null || playlistsData === void 0 ? void 0 : playlistsData.map((playlist)=>{\n                var _playlist_playlist_songs, _playlistSongs_;\n                const playlistSongs = ((_playlist_playlist_songs = playlist.playlist_songs) === null || _playlist_playlist_songs === void 0 ? void 0 : _playlist_playlist_songs.map((ps)=>convertDatabaseSong(ps.songs, likedSongs.has(ps.songs.file_id)))) || [];\n                return {\n                    id: playlist.id.toString(),\n                    name: playlist.name,\n                    songCount: playlistSongs.length,\n                    image: ((_playlistSongs_ = playlistSongs[0]) === null || _playlistSongs_ === void 0 ? void 0 : _playlistSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                    songs: playlistSongs\n                };\n            })) || [];\n            setPlaylists(convertedPlaylists);\n        } catch (error) {\n            console.error(\"Error fetching playlists:\", error);\n        }\n    };\n    // Toggle like song\n    const toggleLike = async (songId)=>{\n        if (!user) return;\n        const songFileId = parseInt(songId);\n        const isCurrentlyLiked = likedSongs.has(songFileId);\n        try {\n            if (isCurrentlyLiked) {\n                // Remove from liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").delete().eq(\"user_id\", user.id).eq(\"song_id\", songFileId);\n                if (error) throw error;\n                // Decrement likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"decrement_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>{\n                    const newSet = new Set(prev);\n                    newSet.delete(songFileId);\n                    return newSet;\n                });\n            } else {\n                // Add to liked_songs\n                const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"liked_songs\").insert({\n                    user_id: user.id,\n                    song_id: songFileId\n                });\n                if (error) throw error;\n                // Increment likes\n                await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_likes\", {\n                    song_file_id: songFileId\n                });\n                setLikedSongs((prev)=>new Set(prev).add(songFileId));\n            }\n            // Update songs state\n            // Update songs state\n            setSongs((prevSongs)=>prevSongs.map((song)=>song.id === songId ? {\n                        ...song,\n                        isLiked: !isCurrentlyLiked,\n                        likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                    } : song));\n            // Update playlists state\n            setPlaylists((prevPlaylists)=>prevPlaylists.map((playlist)=>({\n                        ...playlist,\n                        songs: playlist.songs.map((song)=>song.id === songId ? {\n                                ...song,\n                                isLiked: !isCurrentlyLiked,\n                                likes: song.likes + (isCurrentlyLiked ? -1 : 1)\n                            } : song)\n                    })));\n        } catch (error) {\n            console.error(\"Error toggling like:\", error);\n        }\n    };\n    // Create playlist\n    const createPlaylist = async (name)=>{\n        if (!user) return;\n        try {\n            const { data, error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").insert({\n                user_id: user.id,\n                name\n            }).select().single();\n            if (error) throw error;\n            const newPlaylist = {\n                id: data.id.toString(),\n                name: data.name,\n                songCount: 0,\n                image: \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\",\n                songs: []\n            };\n            setPlaylists((prev)=>[\n                    ...prev,\n                    newPlaylist\n                ]);\n        } catch (error) {\n            console.error(\"Error creating playlist:\", error);\n        }\n    };\n    // Delete playlist\n    const deletePlaylist = async (playlistId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").delete().eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.filter((playlist)=>playlist.id !== playlistId));\n        } catch (error) {\n            console.error(\"Error deleting playlist:\", error);\n        }\n    };\n    // Rename playlist\n    const renamePlaylist = async (playlistId, newName)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlists\").update({\n                name: newName\n            }).eq(\"id\", parseInt(playlistId)).eq(\"user_id\", user.id);\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>playlist.id === playlistId ? {\n                        ...playlist,\n                        name: newName\n                    } : playlist));\n        } catch (error) {\n            console.error(\"Error renaming playlist:\", error);\n        }\n    };\n    // Add song to playlist\n    const addSongToPlaylist = async (playlistId, song)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").insert({\n                playlist_id: parseInt(playlistId),\n                song_id: song.file_id\n            });\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        const songExists = playlist.songs.some((s)=>s.id === song.id);\n                        if (!songExists) {\n                            var _updatedSongs_;\n                            const updatedSongs = [\n                                ...playlist.songs,\n                                song\n                            ];\n                            return {\n                                ...playlist,\n                                songs: updatedSongs,\n                                songCount: updatedSongs.length,\n                                image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || playlist.image\n                            };\n                        }\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error adding song to playlist:\", error);\n        }\n    };\n    // Remove song from playlist\n    const removeSongFromPlaylist = async (playlistId, songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"playlist_songs\").delete().eq(\"playlist_id\", parseInt(playlistId)).eq(\"song_id\", parseInt(songId));\n            if (error) throw error;\n            setPlaylists((prev)=>prev.map((playlist)=>{\n                    if (playlist.id === playlistId) {\n                        var _updatedSongs_;\n                        const updatedSongs = playlist.songs.filter((song)=>song.id !== songId);\n                        return {\n                            ...playlist,\n                            songs: updatedSongs,\n                            songCount: updatedSongs.length,\n                            image: ((_updatedSongs_ = updatedSongs[0]) === null || _updatedSongs_ === void 0 ? void 0 : _updatedSongs_.image) || \"https://images.pexels.com/photos/1763075/pexels-photo-1763075.jpeg?auto=compress&cs=tinysrgb&w=300\"\n                        };\n                    }\n                    return playlist;\n                }));\n        } catch (error) {\n            console.error(\"Error removing song from playlist:\", error);\n        }\n    };\n    // Update last song in user profile\n    const updateLastSong = async (songId)=>{\n        if (!user) return;\n        try {\n            const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.from(\"users\").update({\n                last_song_file_id: parseInt(songId)\n            }).eq(\"id\", user.id);\n            if (error) throw error;\n        } catch (error) {\n            console.error(\"Error updating last song:\", error);\n        }\n    };\n    // Record listening history with proper time tracking\n    const recordListeningHistory = async (songId)=>{\n        if (!user) return;\n        // If there's a previous song playing, record its listening time\n        if (currentSongRef.current && currentSongStartTime) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history:\", error);\n                    } else {\n                        console.log(\"✅ History updated: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording previous song history:\", error);\n                }\n            }\n        }\n        // Set new song as current\n        currentSongRef.current = songId;\n        setCurrentSongStartTime(new Date());\n        // Update last song in user profile\n        await updateLastSong(songId);\n        try {\n            await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"increment_song_views\", {\n                song_file_id: parseInt(songId)\n            });\n        } catch (error) {\n            console.error(\"Error incrementing song views:\", error);\n        }\n    };\n    // Stop current song tracking (when player is closed)\n    const stopCurrentSongTracking = async ()=>{\n        if (currentSongRef.current && currentSongStartTime && user) {\n            const endTime = new Date();\n            const minutesListened = (endTime.getTime() - currentSongStartTime.getTime()) / (1000 * 60);\n            if (minutesListened > 0.1) {\n                try {\n                    const minutes = Math.round(minutesListened * 100) / 100;\n                    const { error } = await _lib_supabase__WEBPACK_IMPORTED_MODULE_0__.supabase.rpc(\"upsert_history_minutes\", {\n                        user_uuid: user.id,\n                        song_file_id: parseInt(currentSongRef.current),\n                        minutes: minutes\n                    });\n                    if (error) {\n                        console.error(\"❌ Error recording song history on stop:\", error);\n                    } else {\n                        console.log(\"\\uD83D\\uDED1 History updated on stop: +\".concat(minutes, \" mins for song \").concat(currentSongRef.current));\n                    }\n                } catch (error) {\n                    console.error(\"Error recording final song history:\", error);\n                }\n            }\n        }\n        currentSongRef.current = null;\n        setCurrentSongStartTime(null);\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const loadData = async ()=>{\n            if (!user) {\n                // Reset data when user logs out\n                songsCache.current = null;\n                likedSongsCache.current = null;\n                setSongs([]);\n                setPersonalizedSongs([]);\n                setTrendingSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setRecentlyPlayedSongs([]);\n                setLastPlayedSong(null);\n                setLoading(false);\n                return;\n            }\n            try {\n                setLoading(true);\n                await Promise.all([\n                    fetchSongs(),\n                    fetchPlaylists(),\n                    fetchRecentlyPlayed()\n                ]);\n            } catch (error) {\n                console.error(\"Error loading data:\", error);\n                // Reset data on error\n                setSongs([]);\n                setPersonalizedSongs([]);\n                setTrendingSongs([]);\n                setPlaylists([]);\n                setLikedSongs(new Set());\n                setRecentlyPlayedSongs([]);\n                setLastPlayedSong(null);\n            } finally{\n                setLoading(false);\n            }\n        };\n        loadData();\n    }, [\n        user\n    ]);\n    return {\n        songs,\n        personalizedSongs,\n        trendingSongs,\n        playlists,\n        likedSongs: songs.filter((song)=>song.isLiked),\n        recentlyPlayedSongs,\n        lastPlayedSong,\n        loading,\n        toggleLike,\n        createPlaylist,\n        deletePlaylist,\n        renamePlaylist,\n        addSongToPlaylist,\n        removeSongFromPlaylist,\n        recordListeningHistory,\n        stopCurrentSongTracking,\n        refreshData: ()=>{\n            fetchSongs();\n            fetchPlaylists();\n            fetchRecentlyPlayed();\n        },\n        getPersonalizedSongs,\n        getSmartPersonalizedSongs\n    };\n}\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2hvb2tzL3VzZVN1cGFiYXNlRGF0YS50cyIsIm1hcHBpbmdzIjoiOzs7Ozs7O0FBQXdEO0FBR0o7QUFFN0MsU0FBU0ksZ0JBQWdCQyxJQUFpQjtJQUMvQyxtRUFBbUU7SUFDbkUsTUFBTUMsYUFBYUosNkNBQU1BLENBQWU7SUFDeEMsTUFBTUssa0JBQWtCTCw2Q0FBTUEsQ0FBcUI7SUFDbkQsTUFBTSxDQUFDTSxPQUFPQyxTQUFTLEdBQUdOLCtDQUFRQSxDQUFTLEVBQUU7SUFDN0MsMEVBQTBFO0lBQzFFLE1BQU0sQ0FBQ08sbUJBQW1CQyxxQkFBcUIsR0FBR1IsK0NBQVFBLENBQVMsRUFBRTtJQUNyRSwrQ0FBK0M7SUFDL0MsTUFBTSxDQUFDUyxlQUFlQyxpQkFBaUIsR0FBR1YsK0NBQVFBLENBQVMsRUFBRTtJQUM3RCxNQUFNLENBQUNXLFdBQVdDLGFBQWEsR0FBR1osK0NBQVFBLENBQWEsRUFBRTtJQUN6RCxNQUFNLENBQUNhLFlBQVlDLGNBQWMsR0FBR2QsK0NBQVFBLENBQWMsSUFBSWU7SUFDOUQsTUFBTSxDQUFDQyxnQkFBZ0JDLGtCQUFrQixHQUFHakIsK0NBQVFBLENBQWM7SUFDbEUsTUFBTSxDQUFDa0IscUJBQXFCQyx1QkFBdUIsR0FBR25CLCtDQUFRQSxDQUFTLEVBQUU7SUFDekUsTUFBTSxDQUFDb0IsU0FBU0MsV0FBVyxHQUFHckIsK0NBQVFBLENBQUM7SUFDdkMsTUFBTSxDQUFDc0Isc0JBQXNCQyx3QkFBd0IsR0FBR3ZCLCtDQUFRQSxDQUFjO0lBQzlFLE1BQU13QixpQkFBaUJ6Qiw2Q0FBTUEsQ0FBZ0I7SUFFN0Msc0VBQXNFO0lBQ3RFLE1BQU0wQiw0QkFBNEIsT0FDaENDLFFBQ0FDLHNCQUNBQztRQUVBLElBQUk7Z0JBc0RxQkQ7WUFyRHZCRSxRQUFRQyxHQUFHLENBQUM7WUFDWkQsUUFBUUMsR0FBRyxDQUFDLGlEQUF1Q0gscUJBQXFCSSxHQUFHLENBQUNDLENBQUFBLElBQUtBLEVBQUVDLElBQUk7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O0FBQ0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vaG9va3MvdXNlU3VwYWJhc2VEYXRhLnRzP2FiZmMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRGF0YWJhc2VTb25nLCBzdXBhYmFzZSB9IGZyb20gJ0AvbGliL3N1cGFiYXNlJztcbmltcG9ydCB7IFBsYXlsaXN0LCBTb25nIH0gZnJvbSAnQC90eXBlcyc7XG5pbXBvcnQgeyBVc2VyIH0gZnJvbSAnQHN1cGFiYXNlL3N1cGFiYXNlLWpzJztcbmltcG9ydCB7IHVzZUVmZmVjdCwgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcblxuZXhwb3J0IGZ1bmN0aW9uIHVzZVN1cGFiYXNlRGF0YSh1c2VyOiBVc2VyIHwgbnVsbCkge1xuICAvLyBDYWNoZXMgZm9yIHNvbmdzIGFuZCBsaWtlZCBzb25ncyB0byBhdm9pZCByZXBlYXRlZCBjbG91ZCBmZXRjaGVzXG4gIGNvbnN0IHNvbmdzQ2FjaGUgPSB1c2VSZWY8YW55W10gfCBudWxsPihudWxsKTtcbiAgY29uc3QgbGlrZWRTb25nc0NhY2hlID0gdXNlUmVmPFNldDxudW1iZXI+IHwgbnVsbD4obnVsbCk7XG4gIGNvbnN0IFtzb25ncywgc2V0U29uZ3NdID0gdXNlU3RhdGU8U29uZ1tdPihbXSlcbiAgLy8gUGVyc29uYWxpemVkIHNvbmdzIHN0YXRlIChzbWFydCBzb3J0ZWQsIGZpbHRlcmVkLCBhbmQgaGlzdG9yeS1leGNsdWRlZClcbiAgY29uc3QgW3BlcnNvbmFsaXplZFNvbmdzLCBzZXRQZXJzb25hbGl6ZWRTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICAvLyBUcmVuZGluZyBzb25ncyBzdGF0ZSAodG9wIDE1IGJ5IHZpZXdzK2xpa2VzKVxuICBjb25zdCBbdHJlbmRpbmdTb25ncywgc2V0VHJlbmRpbmdTb25nc10gPSB1c2VTdGF0ZTxTb25nW10+KFtdKVxuICBjb25zdCBbcGxheWxpc3RzLCBzZXRQbGF5bGlzdHNdID0gdXNlU3RhdGU8UGxheWxpc3RbXT4oW10pXG4gIGNvbnN0IFtsaWtlZFNvbmdzLCBzZXRMaWtlZFNvbmdzXSA9IHVzZVN0YXRlPFNldDxudW1iZXI+PihuZXcgU2V0KCkpXG4gIGNvbnN0IFtsYXN0UGxheWVkU29uZywgc2V0TGFzdFBsYXllZFNvbmddID0gdXNlU3RhdGU8U29uZyB8IG51bGw+KG51bGwpXG4gIGNvbnN0IFtyZWNlbnRseVBsYXllZFNvbmdzLCBzZXRSZWNlbnRseVBsYXllZFNvbmdzXSA9IHVzZVN0YXRlPFNvbmdbXT4oW10pXG4gIGNvbnN0IFtsb2FkaW5nLCBzZXRMb2FkaW5nXSA9IHVzZVN0YXRlKHRydWUpXG4gIGNvbnN0IFtjdXJyZW50U29uZ1N0YXJ0VGltZSwgc2V0Q3VycmVudFNvbmdTdGFydFRpbWVdID0gdXNlU3RhdGU8RGF0ZSB8IG51bGw+KG51bGwpXG4gIGNvbnN0IGN1cnJlbnRTb25nUmVmID0gdXNlUmVmPHN0cmluZyB8IG51bGw+KG51bGwpXG5cbiAgLy8gR2V0IHBlcnNvbmFsaXplZCBzb25ncyBiYXNlZCBvbiB1c2VyJ3MgYWN0dWFsIGxpc3RlbmluZyBwcmVmZXJlbmNlc1xuICBjb25zdCBnZXRTbWFydFBlcnNvbmFsaXplZFNvbmdzID0gYXN5bmMgKFxuICAgIHVzZXJJZDogc3RyaW5nLFxuICAgIGxpc3RlbmVkU29uZ3NJbkJhdGNoOiBTb25nW10sIFxuICAgIGV4Y2x1ZGVTb25nczogU2V0PHN0cmluZz5cbiAgKTogUHJvbWlzZTxTb25nW10+ID0+IHtcbiAgICB0cnkge1xuICAgICAgY29uc29sZS5sb2coJ/Cfp6AgRmV0Y2hpbmcgc21hcnQgcGVyc29uYWxpemVkIHNvbmdzIGJhc2VkIG9uIGxpc3RlbmluZyBiZWhhdmlvcicpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgU29uZ3MgdXNlciBhY3R1YWxseSBsaXN0ZW5lZCB0bzonLCBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5tYXAocyA9PiBzLm5hbWUpKTtcbiAgICAgIFxuICAgICAgaWYgKGxpc3RlbmVkU29uZ3NJbkJhdGNoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBjb25zb2xlLmxvZygn4pqg77iPIE5vIGxpc3RlbmVkIHNvbmdzIGluIGJhdGNoLCBmYWxsaW5nIGJhY2sgdG8gcmVndWxhciBwZXJzb25hbGl6YXRpb24nKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyBFeHRyYWN0IHRhZ3MgYW5kIGFydGlzdHMgZnJvbSBsaXN0ZW5lZCBzb25nc1xuICAgICAgY29uc3QgcHJlZmVycmVkVGFncyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgY29uc3QgcHJlZmVycmVkQXJ0aXN0cyA9IG5ldyBTZXQ8c3RyaW5nPigpO1xuICAgICAgXG4gICAgICBsaXN0ZW5lZFNvbmdzSW5CYXRjaC5mb3JFYWNoKHNvbmcgPT4ge1xuICAgICAgICBzb25nLnRhZ3M/LmZvckVhY2godGFnID0+IHByZWZlcnJlZFRhZ3MuYWRkKHRhZy50b0xvd2VyQ2FzZSgpKSk7XG4gICAgICAgIHByZWZlcnJlZEFydGlzdHMuYWRkKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKCfwn4+377iPIFByZWZlcnJlZCB0YWdzOicsIEFycmF5LmZyb20ocHJlZmVycmVkVGFncykpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjqQgUHJlZmVycmVkIGFydGlzdHM6JywgQXJyYXkuZnJvbShwcmVmZXJyZWRBcnRpc3RzKSk7XG5cbiAgICAgIC8vIFVzZSBjYWNoZSBpZiBhdmFpbGFibGUsIG90aGVyd2lzZSBmZXRjaCBhbmQgY2FjaGVcbiAgICAgIGxldCBzb25nc0RhdGEgPSBzb25nc0NhY2hlLmN1cnJlbnQ7XG4gICAgICBpZiAoIXNvbmdzRGF0YSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3MgZm9yIHNtYXJ0IHBlcnNvbmFsaXphdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHNvbmdzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHNvbmdzRGF0YSA9IGRhdGE7XG4gICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIGxldCB1c2VyTGlrZWRTb25ncyA9IGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50O1xuICAgICAgaWYgKCF1c2VyTGlrZWRTb25ncykge1xuICAgICAgICBjb25zdCB7IGRhdGE6IGxpa2VkRGF0YSB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAgIC5zZWxlY3QoJ3NvbmdfaWQnKVxuICAgICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXJJZCk7XG4gICAgICAgIHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KCk7XG4gICAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzIS5hZGQoaXRlbS5zb25nX2lkKSk7XG4gICAgICAgIH1cbiAgICAgICAgbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQgPSB1c2VyTGlrZWRTb25ncztcbiAgICAgIH1cblxuICAgICAgLy8gRmlsdGVyIGFuZCBzY29yZSBzb25ncyBiYXNlZCBvbiBsaXN0ZW5pbmcgcHJlZmVyZW5jZXMgYW5kIGxhbmd1YWdlXG4gICAgICAvLyBVc2UgdGhlIGxhbmd1YWdlIG9mIHRoZSBmaXJzdCBsaXN0ZW5lZCBzb25nIGFzIHRoZSBmaWx0ZXJcbiAgICAgIGNvbnN0IGxhbmd1YWdlRmlsdGVyID0gbGlzdGVuZWRTb25nc0luQmF0Y2hbMF0/Lmxhbmd1YWdlO1xuICAgICAgY29uc3QgYXZhaWxhYmxlU29uZ3MgPSBzb25nc0RhdGEuZmlsdGVyKChzb25nKSA9PiB7XG4gICAgICAgIHJldHVybiAoXG4gICAgICAgICAgIWV4Y2x1ZGVTb25ncy5oYXMoc29uZy5maWxlX2lkLnRvU3RyaW5nKCkpICYmXG4gICAgICAgICAgc29uZy5sYW5ndWFnZSA9PT0gbGFuZ3VhZ2VGaWx0ZXJcbiAgICAgICAgKTtcbiAgICAgIH0pO1xuXG4gICAgICBjb25zb2xlLmxvZyhg8J+OtSBBdmFpbGFibGUgc29uZ3MgZm9yIHNtYXJ0IHJlY29tbWVuZGF0aW9ucyAobGFuZ3VhZ2U6ICR7bGFuZ3VhZ2VGaWx0ZXJ9KTogJHthdmFpbGFibGVTb25ncy5sZW5ndGh9YCk7XG5cbiAgICAgIGlmIChhdmFpbGFibGVTb25ncy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29uc29sZS53YXJuKCfimqDvuI8gTm8gYXZhaWxhYmxlIHNvbmdzIGFmdGVyIGZpbHRlcmluZycpO1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG5cbiAgICAgIC8vIFNjb3JlIHNvbmdzIGJhc2VkIG9uIHVzZXIncyBsaXN0ZW5pbmcgcHJlZmVyZW5jZXNcbiAgICAgIGNvbnN0IHNjb3JlZFNvbmdzID0gYXZhaWxhYmxlU29uZ3MubWFwKChzb25nKSA9PiB7XG4gICAgICAgIGxldCBzY29yZSA9IDA7XG5cbiAgICAgICAgLy8gSGlnaCBwcmlvcml0eTogVGFnIG1hdGNoaW5nIHdpdGggbGlzdGVuZWQgc29uZ3NcbiAgICAgICAgY29uc3Qgc29uZ1RhZ3MgPSBzb25nLnRhZ3M/Lm1hcCgodGFnOiBzdHJpbmcpID0+IHRhZy50b0xvd2VyQ2FzZSgpKSB8fCBbXTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdUYWdzID0gc29uZ1RhZ3MuZmlsdGVyKCh0YWc6IHN0cmluZykgPT4gcHJlZmVycmVkVGFncy5oYXModGFnKSk7XG4gICAgICAgIHNjb3JlICs9IG1hdGNoaW5nVGFncy5sZW5ndGggKiAyNTsgLy8gSGlnaGVyIHdlaWdodCBmb3IgdGFnIG1hdGNoaW5nXG5cbiAgICAgICAgLy8gSGlnaCBwcmlvcml0eTogQXJ0aXN0IG1hdGNoaW5nIHdpdGggbGlzdGVuZWQgc29uZ3NcbiAgICAgICAgaWYgKHByZWZlcnJlZEFydGlzdHMuaGFzKHNvbmcuYXJ0aXN0LnRvTG93ZXJDYXNlKCkpKSB7XG4gICAgICAgICAgc2NvcmUgKz0gMzA7IC8vIEhpZ2hlciB3ZWlnaHQgZm9yIGFydGlzdCBtYXRjaGluZ1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTWVkaXVtIHByaW9yaXR5OiBTYW1lIGxhbmd1YWdlIGFzIGxpc3RlbmVkIHNvbmdzXG4gICAgICAgIGNvbnN0IGxpc3RlbmVkTGFuZ3VhZ2VzID0gbGlzdGVuZWRTb25nc0luQmF0Y2gubWFwKHMgPT4gcy5sYW5ndWFnZSk7XG4gICAgICAgIGlmIChsaXN0ZW5lZExhbmd1YWdlcy5pbmNsdWRlcyhzb25nLmxhbmd1YWdlKSkge1xuICAgICAgICAgIHNjb3JlICs9IDE1O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTG93ZXIgcHJpb3JpdHk6IEdlbmVyYWwgcG9wdWxhcml0eVxuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcubGlrZXMgfHwgMCkpICogMjtcbiAgICAgICAgc2NvcmUgKz0gTWF0aC5sb2coMSArIChzb25nLnZpZXdzIHx8IDApKSAqIDE7XG5cbiAgICAgICAgLy8gQm9udXMgZm9yIGxpa2VkIHNvbmdzXG4gICAgICAgIGlmICh1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSkge1xuICAgICAgICAgIHNjb3JlICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHNtYWxsIHJhbmRvbW5lc3MgdG8gYXZvaWQgcmVwZXRpdGlvblxuICAgICAgICBzY29yZSArPSBNYXRoLnJhbmRvbSgpICogMjtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHNvbmc6IGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpLCBcbiAgICAgICAgICBzY29yZVxuICAgICAgICB9O1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFNvcnQgYnkgc2NvcmUgYW5kIHJldHVybiB0b3AgcmVjb21tZW5kYXRpb25zXG4gICAgICBjb25zdCByZWNvbW1lbmRhdGlvbnMgPSBzY29yZWRTb25nc1xuICAgICAgICAuc29ydCgoYSwgYikgPT4gYi5zY29yZSAtIGEuc2NvcmUpXG4gICAgICAgIC5zbGljZSgwLCAxNSkgLy8gR2V0IG1vcmUgc29uZ3MgZm9yIHZhcmlldHlcbiAgICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zb25nKTtcblxuICAgICAgY29uc29sZS5sb2coJ/Cfp6AgU21hcnQgcmVjb21tZW5kYXRpb25zIGJhc2VkIG9uIGxpc3RlbmluZyBiZWhhdmlvcjonLCBcbiAgICAgICAgcmVjb21tZW5kYXRpb25zLnNsaWNlKDAsIDUpLm1hcChzID0+IGAke3MubmFtZX0gYnkgJHtzLmFydGlzdH1gKSk7XG4gICAgICBcbiAgICAgIHJldHVybiByZWNvbW1lbmRhdGlvbnM7XG4gICAgICBcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGluIGdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3M6JywgZXJyb3IpO1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cbiAgfTtcblxuICAvLyBDb252ZXJ0IGRhdGFiYXNlIHNvbmcgdG8gVUkgc29uZyBmb3JtYXRcbiAgY29uc3QgY29udmVydERhdGFiYXNlU29uZyA9IChkYlNvbmc6IERhdGFiYXNlU29uZywgaXNMaWtlZDogYm9vbGVhbiA9IGZhbHNlKTogU29uZyA9PiAoe1xuICAgIGZpbGVfaWQ6IGRiU29uZy5maWxlX2lkLFxuICAgIGltZ19pZDogZGJTb25nLmltZ19pZCxcbiAgICBuYW1lOiBkYlNvbmcubmFtZSxcbiAgICBhcnRpc3Q6IGRiU29uZy5hcnRpc3QsXG4gICAgbGFuZ3VhZ2U6IGRiU29uZy5sYW5ndWFnZSxcbiAgICB0YWdzOiBkYlNvbmcudGFncyxcbiAgICB2aWV3czogZGJTb25nLnZpZXdzLFxuICAgIGxpa2VzOiBkYlNvbmcubGlrZXMsXG4gICAgaWQ6IGRiU29uZy5maWxlX2lkLnRvU3RyaW5nKCksXG4gICAgaW1hZ2U6IGBodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8ke2RiU29uZy5pbWdfaWR9L3BleGVscy1waG90by0ke2RiU29uZy5pbWdfaWR9LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMGAsXG4gICAgaXNMaWtlZFxuICB9KVxuXG4gIC8vIEZldGNoIGFsbCBzb25nc1xuICBjb25zdCBmZXRjaFNvbmdzID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0U29uZ3MoW10pXG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgXG4gICAgdHJ5IHtcbiAgICAgIGNvbnNvbGUubG9nKCdGZXRjaGluZyBhbGwgc29uZ3MgZnJvbSBzdXBhYmFzZS4uLicpO1xuICAgICAgY29uc3QgeyBkYXRhOiBzb25nc0RhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCcqJylcbiAgICAgICAgLm9yZGVyKCd2aWV3cycsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuICAgICAgY29uc29sZS5sb2coJ0ZldGNoZWQgc29uZ3M6Jywgc29uZ3NEYXRhPy5sZW5ndGgpO1xuXG4gICAgICAvLyBGZXRjaCBsaWtlZCBzb25nc1xuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbmV3IFNldDxudW1iZXI+KClcbiAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgIGlmIChsaWtlZERhdGEpIHtcbiAgICAgICAgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0KGxpa2VkRGF0YS5tYXAoaXRlbSA9PiBpdGVtLnNvbmdfaWQpKVxuICAgICAgICBzZXRMaWtlZFNvbmdzKHVzZXJMaWtlZFNvbmdzKVxuICAgICAgfVxuXG4gICAgICAvLyBGZXRjaCB1c2VyIGhpc3RvcnkgKGZvciBtaW51dGVzX2xpc3RlbmVkKVxuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSwgZXJyb3I6IGhpc3RvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkLCBtaW51dGVzX2xpc3RlbmVkLCBzb25ncygqKScpXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG4gICAgICAgIC5vcmRlcignbWludXRlc19saXN0ZW5lZCcsIHsgYXNjZW5kaW5nOiBmYWxzZSB9KVxuICAgICAgaWYgKGhpc3RvcnlFcnJvcikgdGhyb3cgaGlzdG9yeUVycm9yXG4gICAgICBjb25zb2xlLmxvZygnRmV0Y2hlZCB1c2VyIGhpc3Rvcnk6JywgaGlzdG9yeURhdGE/Lmxlbmd0aCk7XG5cbiAgICAgIC8vIEdldCB0b3AgMTUgbW9zdCBsaXN0ZW5lZCBzb25ncyBmcm9tIGhpc3RvcnlcbiAgICAgIGNvbnN0IHRvcEhpc3RvcnkgPSAoaGlzdG9yeURhdGEgfHwgW10pLnNsaWNlKDAsIDE1KS5maWx0ZXIoaCA9PiBoLnNvbmdzKVxuICAgICAgLy8gQ29sbGVjdCB0YWdzIGFuZCBhcnRpc3RzIGZyb20gdG9wIDE1XG4gICAgICBjb25zdCB0YWdDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG4gICAgICBjb25zdCBhcnRpc3RDb3VudDogUmVjb3JkPHN0cmluZywgbnVtYmVyPiA9IHt9XG4gICAgICB0b3BIaXN0b3J5LmZvckVhY2goaCA9PiB7XG4gICAgICAgIC8vIGguc29uZ3MgbWF5IGJlIGFuIGFycmF5IG9yIG9iamVjdCwgdXNlIGZpcnN0IGlmIGFycmF5XG4gICAgICAgIGNvbnN0IHNvbmdPYmogPSBBcnJheS5pc0FycmF5KGguc29uZ3MpID8gaC5zb25nc1swXSA6IGguc29uZ3M7XG4gICAgICAgIChzb25nT2JqPy50YWdzIHx8IFtdKS5mb3JFYWNoKCh0YWc6IHN0cmluZykgPT4ge1xuICAgICAgICAgIGNvbnN0IHQgPSB0YWcudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICB0YWdDb3VudFt0XSA9ICh0YWdDb3VudFt0XSB8fCAwKSArIDE7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoc29uZ09iaj8uYXJ0aXN0KSB7XG4gICAgICAgICAgY29uc3QgYSA9IHNvbmdPYmouYXJ0aXN0LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgYXJ0aXN0Q291bnRbYV0gPSAoYXJ0aXN0Q291bnRbYV0gfHwgMCkgKyAxO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIC8vIEZpbmQgbW9zdCBjb21tb24gdGFncyBhbmQgYXJ0aXN0c1xuICAgICAgY29uc3QgY29tbW9uVGFncyA9IE9iamVjdC5lbnRyaWVzKHRhZ0NvdW50KVxuICAgICAgICAuc29ydCgoYSwgYikgPT4gYlsxXSAtIGFbMV0pXG4gICAgICAgIC5zbGljZSgwLCA1KVxuICAgICAgICAubWFwKChbdGFnXSkgPT4gdGFnKTtcbiAgICAgIGNvbnN0IGNvbW1vbkFydGlzdHMgPSBPYmplY3QuZW50cmllcyhhcnRpc3RDb3VudClcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGJbMV0gLSBhWzFdKVxuICAgICAgICAuc2xpY2UoMCwgNSlcbiAgICAgICAgLm1hcCgoW2FydGlzdF0pID0+IGFydGlzdCk7XG4gICAgICBjb25zb2xlLmxvZygnRm91bmQgc2ltaWxhciB0YWdzOicsIGNvbW1vblRhZ3MpO1xuICAgICAgY29uc29sZS5sb2coJ0ZvdW5kIHNpbWlsYXIgYXJ0aXN0czonLCBjb21tb25BcnRpc3RzKTtcblxuICAgICAgLy8gU29uZ3MgaW4gaGlzdG9yeSAodG8gZXhjbHVkZSBmb3Igc21hcnQgc29ydClcbiAgICAgIGNvbnN0IGhpc3RvcnlTb25nSWRzID0gbmV3IFNldCgoaGlzdG9yeURhdGEgfHwgW10pLm1hcChoID0+IGguc29uZ19pZD8udG9TdHJpbmcoKSkpO1xuXG4gICAgICAvLyBDb252ZXJ0IGFsbCBzb25nc1xuICAgICAgY29uc3QgY29udmVydGVkU29uZ3MgPSBzb25nc0RhdGE/Lm1hcChzb25nID0+XG4gICAgICAgIGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZywgdXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpXG4gICAgICApIHx8IFtdO1xuXG4gICAgICBzZXRTb25ncyhjb252ZXJ0ZWRTb25ncyk7IC8vIHNvbmdzIGlzIG5vdyBhbGwgc29uZ3MsIG5vdCBwZXJzb25hbGl6ZWRcblxuICAgICAgLy8gRmlsdGVyIG91dCBzb25ncyBpbiBoaXN0b3J5IGZvciBwZXJzb25hbGl6ZWQgc29ydFxuICAgICAgY29uc3QgZmlsdGVyZWRTb25ncyA9IGNvbnZlcnRlZFNvbmdzLmZpbHRlcihzb25nID0+ICFoaXN0b3J5U29uZ0lkcy5oYXMoc29uZy5pZCkpO1xuXG4gICAgICAvLyBTY29yZSBzb25ncyBieSB0YWcvYXJ0aXN0IG1hdGNoXG4gICAgICBjb25zdCBzY29yZWRTb25ncyA9IGZpbHRlcmVkU29uZ3MubWFwKHNvbmcgPT4ge1xuICAgICAgICBsZXQgc2NvcmUgPSAwO1xuICAgICAgICAvLyBUYWcgbWF0Y2hcbiAgICAgICAgY29uc3Qgc29uZ1RhZ3MgPSAoc29uZy50YWdzIHx8IFtdKS5tYXAoKHQ6IHN0cmluZykgPT4gdC50b0xvd2VyQ2FzZSgpKTtcbiAgICAgICAgc2NvcmUgKz0gc29uZ1RhZ3MuZmlsdGVyKHQgPT4gY29tbW9uVGFncy5pbmNsdWRlcyh0KSkubGVuZ3RoICogMTA7XG4gICAgICAgIC8vIEFydGlzdCBtYXRjaFxuICAgICAgICBpZiAoc29uZy5hcnRpc3QgJiYgY29tbW9uQXJ0aXN0cy5pbmNsdWRlcyhzb25nLmFydGlzdC50b0xvd2VyQ2FzZSgpKSkge1xuICAgICAgICAgIHNjb3JlICs9IDIwO1xuICAgICAgICB9XG4gICAgICAgIC8vIFBvcHVsYXJpdHlcbiAgICAgICAgc2NvcmUgKz0gKHNvbmcudmlld3MgfHwgMCkgKyAoc29uZy5saWtlcyB8fCAwKTtcbiAgICAgICAgcmV0dXJuIHsgc29uZywgc2NvcmUgfTtcbiAgICAgIH0pO1xuICAgICAgLy8gU29ydCBieSBzY29yZSBkZXNjZW5kaW5nXG4gICAgICBjb25zdCBwZXJzb25hbGl6ZWRTb3J0ZWQgPSBzY29yZWRTb25ncy5zb3J0KChhLCBiKSA9PiBiLnNjb3JlIC0gYS5zY29yZSkubWFwKHMgPT4gcy5zb25nKTtcblxuICAgICAgc2V0UGVyc29uYWxpemVkU29uZ3MocGVyc29uYWxpemVkU29ydGVkKTtcblxuICAgICAgLy8gVHJlbmRpbmc6IHRvcCAxNSBieSB2aWV3cytsaWtlcyAoZnJvbSBhbGwgc29uZ3MsIGluY2x1ZGluZyBoaXN0b3J5KVxuICAgICAgY29uc3QgdHJlbmRpbmcgPSBbLi4uY29udmVydGVkU29uZ3NdXG4gICAgICAgIC5zb3J0KChhLCBiKSA9PiAoYi52aWV3cyArIGIubGlrZXMpIC0gKGEudmlld3MgKyBhLmxpa2VzKSlcbiAgICAgICAgLnNsaWNlKDAsIDE1KTtcbiAgICAgIHNldFRyZW5kaW5nU29uZ3ModHJlbmRpbmcpO1xuICAgICAgY29uc29sZS5sb2coJ1RyZW5kaW5nIHNvbmdzOicsIHRyZW5kaW5nLm1hcChzID0+IGAke3MubmFtZX0gKCR7cy52aWV3c30gdmlld3MsICR7cy5saWtlc30gbGlrZXMpYCkpO1xuXG4gICAgICAvLyBTZXQgbGFzdCBwbGF5ZWQgc29uZyBhcyBiZWZvcmVcbiAgICAgIGNvbnN0IHsgZGF0YTogdXNlckRhdGEgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCd1c2VycycpXG4gICAgICAgIC5zZWxlY3QoJ2xhc3Rfc29uZ19maWxlX2lkJylcbiAgICAgICAgLmVxKCdpZCcsIHVzZXIuaWQpXG4gICAgICAgIC5zaW5nbGUoKTtcbiAgICAgIGlmICh1c2VyRGF0YT8ubGFzdF9zb25nX2ZpbGVfaWQpIHtcbiAgICAgICAgY29uc3QgbGFzdFNvbmcgPSBjb252ZXJ0ZWRTb25ncy5maW5kKHNvbmcgPT4gc29uZy5maWxlX2lkID09PSB1c2VyRGF0YS5sYXN0X3NvbmdfZmlsZV9pZClcbiAgICAgICAgaWYgKGxhc3RTb25nKSB7XG4gICAgICAgICAgc2V0TGFzdFBsYXllZFNvbmcobGFzdFNvbmcpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgc29uZ3M6JywgZXJyb3IpXG4gICAgICBzZXRTb25ncyhbXSlcbiAgICB9XG4gIH1cblxuICAvLyBHZXQgcGVyc29uYWxpemVkIHNvbmdzIHdpdGggcHJvcGVyIGVycm9yIGhhbmRsaW5nIGFuZCBmaWx0ZXJpbmdcbiAgY29uc3QgZ2V0UGVyc29uYWxpemVkU29uZ3MgPSBhc3luYyAodXNlcklkOiBzdHJpbmcsIGN1cnJlbnRTb25nOiBTb25nLCBsaXN0ZW5lZFNvbmdzPzogU2V0PHN0cmluZz4pOiBQcm9taXNlPFNvbmdbXT4gPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zb2xlLmxvZygn8J+OtSBGZXRjaGluZyBwZXJzb25hbGl6ZWQgc29uZ3MgZm9yOicsIGN1cnJlbnRTb25nLm5hbWUpO1xuICAgICAgY29uc29sZS5sb2coJ/CfjrUgTGlzdGVuZWQgc29uZ3MgY291bnQ6JywgbGlzdGVuZWRTb25ncz8uc2l6ZSB8fCAwKTtcbiAgICAgIFxuICAgICAgLy8gMS4gRmV0Y2ggYWxsIHNvbmdzIGZyb20gY2FjaGUgb3IgY2xvdWRcbiAgICAgIGxldCBzb25nc0RhdGEgPSBzb25nc0NhY2hlLmN1cnJlbnQ7XG4gICAgICBpZiAoIXNvbmdzRGF0YSkge1xuICAgICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdzb25ncycpXG4gICAgICAgICAgLnNlbGVjdCgnKicpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgZmV0Y2hpbmcgc29uZ3MgZm9yIHBlcnNvbmFsaXphdGlvbjonLCBlcnJvcik7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZGF0YSB8fCBkYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIHNvbmdzIGZvdW5kIGluIGRhdGFiYXNlJyk7XG4gICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIHNvbmdzRGF0YSA9IGRhdGE7XG4gICAgICAgIHNvbmdzQ2FjaGUuY3VycmVudCA9IGRhdGE7XG4gICAgICB9XG5cbiAgICAgIC8vIDIuIEZldGNoIHVzZXIncyBsaXN0ZW5pbmcgaGlzdG9yeSAobm90IGNhY2hlZCwgYXMgaXQgbWF5IGNoYW5nZSBmcmVxdWVudGx5KVxuICAgICAgY29uc3QgeyBkYXRhOiBoaXN0b3J5RGF0YSwgZXJyb3I6IGhpc3RvcnlFcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2hpc3RvcnknKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkLCBtaW51dGVzX2xpc3RlbmVkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcbiAgICAgIGlmIChoaXN0b3J5RXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcign4p2MIEVycm9yIGZldGNoaW5nIGhpc3Rvcnk6JywgaGlzdG9yeUVycm9yKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGhpc3RvcnlNYXAgPSBuZXcgTWFwPG51bWJlciwgbnVtYmVyPigpO1xuICAgICAgaWYgKGhpc3RvcnlEYXRhKSB7XG4gICAgICAgIGhpc3RvcnlEYXRhLmZvckVhY2goaCA9PiBoaXN0b3J5TWFwLnNldChoLnNvbmdfaWQsIGgubWludXRlc19saXN0ZW5lZCB8fCAwKSk7XG4gICAgICB9XG5cbiAgICAgIC8vIDMuIEdldCB1c2VyJ3MgbGlrZWQgc29uZ3MgZnJvbSBjYWNoZSBvciBjbG91ZFxuICAgICAgbGV0IHVzZXJMaWtlZFNvbmdzID0gbGlrZWRTb25nc0NhY2hlLmN1cnJlbnQ7XG4gICAgICBpZiAoIXVzZXJMaWtlZFNvbmdzKSB7XG4gICAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAgIC5mcm9tKCdsaWtlZF9zb25ncycpXG4gICAgICAgICAgLnNlbGVjdCgnc29uZ19pZCcpXG4gICAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlcklkKTtcbiAgICAgICAgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKTtcbiAgICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICAgIGxpa2VkRGF0YS5mb3JFYWNoKGl0ZW0gPT4gdXNlckxpa2VkU29uZ3MhLmFkZChpdGVtLnNvbmdfaWQpKTtcbiAgICAgICAgfVxuICAgICAgICBsaWtlZFNvbmdzQ2FjaGUuY3VycmVudCA9IHVzZXJMaWtlZFNvbmdzO1xuICAgICAgfVxuXG4gICAgICAvLyA0LiBGaWx0ZXIgYW5kIHNjb3JlIHNvbmdzIChhZGQgbGFuZ3VhZ2UgZmlsdGVyKVxuICAgICAgY29uc3QgbGFuZ3VhZ2VGaWx0ZXIgPSBjdXJyZW50U29uZy5sYW5ndWFnZTtcbiAgICAgIGNvbnN0IGF2YWlsYWJsZVNvbmdzID0gc29uZ3NEYXRhLmZpbHRlcigoc29uZykgPT4ge1xuICAgICAgICAvLyBFeGNsdWRlIGN1cnJlbnQgc29uZ1xuICAgICAgICBpZiAoc29uZy5maWxlX2lkID09PSBjdXJyZW50U29uZy5maWxlX2lkKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8vIEV4Y2x1ZGUgbGlzdGVuZWQgc29uZ3MgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKGxpc3RlbmVkU29uZ3MgJiYgbGlzdGVuZWRTb25ncy5oYXMoc29uZy5maWxlX2lkLnRvU3RyaW5nKCkpKSB7XG4gICAgICAgICAgY29uc29sZS5sb2coYPCfmqsgRXhjbHVkaW5nIGxpc3RlbmVkIHNvbmc6ICR7c29uZy5uYW1lfSBieSAke3NvbmcuYXJ0aXN0fWApO1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGluY2x1ZGUgc29uZ3Mgd2l0aCB0aGUgc2FtZSBsYW5ndWFnZSBhcyBjdXJyZW50IHNvbmdcbiAgICAgICAgaWYgKHNvbmcubGFuZ3VhZ2UgIT09IGxhbmd1YWdlRmlsdGVyKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfSk7XG5cbiAgICAgIGNvbnNvbGUubG9nKGDwn461IEF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcgKGxhbmd1YWdlOiAke2xhbmd1YWdlRmlsdGVyfSk6ICR7YXZhaWxhYmxlU29uZ3MubGVuZ3RofWApO1xuXG4gICAgICBpZiAoYXZhaWxhYmxlU29uZ3MubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2Fybign4pqg77iPIE5vIGF2YWlsYWJsZSBzb25ncyBhZnRlciBmaWx0ZXJpbmcnKTtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuXG4gICAgICAvLyA1LiBTY29yZSBhbmQgc29ydCBzb25nc1xuICAgICAgY29uc3Qgc2NvcmVkU29uZ3MgPSBhdmFpbGFibGVTb25ncy5tYXAoKHNvbmcpID0+IHtcbiAgICAgICAgbGV0IHNjb3JlID0gMDtcblxuICAgICAgICAvLyBUYWcgbWF0Y2hpbmcgKGhpZ2hlc3QgcHJpb3JpdHkpXG4gICAgICAgIGNvbnN0IG1hdGNoaW5nVGFncyA9IHNvbmcudGFncz8uZmlsdGVyKCh0YWc6IHN0cmluZykgPT5cbiAgICAgICAgICBjdXJyZW50U29uZy50YWdzPy5pbmNsdWRlcyh0YWcpXG4gICAgICAgICkgfHwgW107XG4gICAgICAgIHNjb3JlICs9IG1hdGNoaW5nVGFncy5sZW5ndGggKiAxNTtcblxuICAgICAgICAvLyBBcnRpc3QgbWF0Y2hpbmdcbiAgICAgICAgaWYgKHNvbmcuYXJ0aXN0ID09PSBjdXJyZW50U29uZy5hcnRpc3QpIHtcbiAgICAgICAgICBzY29yZSArPSAyNTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIExhbmd1YWdlIG1hdGNoaW5nXG4gICAgICAgIGlmIChzb25nLmxhbmd1YWdlID09PSBjdXJyZW50U29uZy5sYW5ndWFnZSkge1xuICAgICAgICAgIHNjb3JlICs9IDEwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gTGlzdGVuaW5nIGhpc3RvcnkgYm9vc3RcbiAgICAgICAgY29uc3QgbGlzdGVuZWRNaW51dGVzID0gaGlzdG9yeU1hcC5nZXQoc29uZy5maWxlX2lkKSB8fCAwO1xuICAgICAgICBzY29yZSArPSBNYXRoLm1pbihsaXN0ZW5lZE1pbnV0ZXMgKiAyLCAyMCk7IC8vIENhcCBhdCAyMCBwb2ludHNcblxuICAgICAgICAvLyBQb3B1bGFyaXR5IGJvb3N0IChsaWtlcyBhbmQgdmlld3MpXG4gICAgICAgIHNjb3JlICs9IE1hdGgubG9nKDEgKyAoc29uZy5saWtlcyB8fCAwKSkgKiAyO1xuICAgICAgICBzY29yZSArPSBNYXRoLmxvZygxICsgKHNvbmcudmlld3MgfHwgMCkpICogMTtcblxuICAgICAgICAvLyBMaWtlZCBzb25ncyBib29zdFxuICAgICAgICBpZiAodXNlckxpa2VkU29uZ3MuaGFzKHNvbmcuZmlsZV9pZCkpIHtcbiAgICAgICAgICBzY29yZSArPSA4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIGNvbnRyb2xsZWQgcmFuZG9tbmVzcyB0byBhdm9pZCByZXBldGl0aW9uXG4gICAgICAgIHNjb3JlICs9IE1hdGgucmFuZG9tKCkgKiAzO1xuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc29uZzogY29udmVydERhdGFiYXNlU29uZyhzb25nLCB1c2VyTGlrZWRTb25ncy5oYXMoc29uZy5maWxlX2lkKSksXG4gICAgICAgICAgc2NvcmVcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyA2LiBTb3J0IGJ5IHNjb3JlIGFuZCByZXR1cm4gdG9wIHJlY29tbWVuZGF0aW9uc1xuICAgICAgY29uc3QgcmVjb21tZW5kYXRpb25zID0gc2NvcmVkU29uZ3NcbiAgICAgICAgLnNvcnQoKGEsIGIpID0+IGIuc2NvcmUgLSBhLnNjb3JlKVxuICAgICAgICAuc2xpY2UoMCwgMTApIC8vIEdldCBtb3JlIHNvbmdzIHRvIGhhdmUgYSBidWZmZXJcbiAgICAgICAgLm1hcChlbnRyeSA9PiBlbnRyeS5zb25nKTtcblxuICAgICAgY29uc29sZS5sb2coJ/CfjrUgUGVyc29uYWxpemVkIHJlY29tbWVuZGF0aW9uczonLCByZWNvbW1lbmRhdGlvbnMuc2xpY2UoMCwgNSkubWFwKHMgPT4gYCR7cy5uYW1lfSBieSAke3MuYXJ0aXN0fWApKTtcbiAgICAgIGNvbnNvbGUubG9nKCfwn461IFRvdGFsIGF2YWlsYWJsZSBzb25nczonLCBhdmFpbGFibGVTb25ncy5sZW5ndGgpO1xuICAgICAgXG4gICAgICByZXR1cm4gcmVjb21tZW5kYXRpb25zO1xuICAgICAgXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciBpbiBnZXRQZXJzb25hbGl6ZWRTb25nczonLCBlcnJvcik7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuICB9O1xuXG4gIC8vIEZldGNoIHJlY2VudGx5IHBsYXllZCBzb25ncyBiYXNlZCBvbiBsaXN0ZW5pbmcgaGlzdG9yeVxuICBjb25zdCBmZXRjaFJlY2VudGx5UGxheWVkID0gYXN5bmMgKCkgPT4ge1xuICAgIGlmICghdXNlcikge1xuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICAvLyBHZXQgdXNlcidzIGxpc3RlbmluZyBoaXN0b3J5IHNvcnRlZCBieSBtaW51dGVzIGxpc3RlbmVkXG4gICAgICBjb25zdCB7IGRhdGE6IGhpc3RvcnlEYXRhLCBlcnJvcjogaGlzdG9yeUVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnaGlzdG9yeScpXG4gICAgICAgIC5zZWxlY3QoYFxuICAgICAgICAgIHNvbmdfaWQsXG4gICAgICAgICAgbWludXRlc19saXN0ZW5lZCxcbiAgICAgICAgICBzb25ncyAoKilcbiAgICAgICAgYClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLm9yZGVyKCdtaW51dGVzX2xpc3RlbmVkJywgeyBhc2NlbmRpbmc6IGZhbHNlIH0pXG4gICAgICAgIC5saW1pdCg5KVxuXG4gICAgICBpZiAoaGlzdG9yeUVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGZldGNoaW5nIHJlY2VudGx5IHBsYXllZDonLCBoaXN0b3J5RXJyb3IpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICBpZiAoIWhpc3RvcnlEYXRhIHx8IGhpc3RvcnlEYXRhLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHVzZXIncyBsaWtlZCBzb25ncyBmb3IgcHJvcGVyIGNvbnZlcnNpb25cbiAgICAgIGNvbnN0IHsgZGF0YTogbGlrZWREYXRhIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuc2VsZWN0KCdzb25nX2lkJylcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgIFxuICAgICAgY29uc3QgdXNlckxpa2VkU29uZ3MgPSBuZXcgU2V0PG51bWJlcj4oKVxuICAgICAgaWYgKGxpa2VkRGF0YSkge1xuICAgICAgICBsaWtlZERhdGEuZm9yRWFjaChpdGVtID0+IHVzZXJMaWtlZFNvbmdzLmFkZChpdGVtLnNvbmdfaWQpKVxuICAgICAgfVxuXG4gICAgICAvLyBDb252ZXJ0IHRvIFNvbmcgZm9ybWF0XG4gICAgICBjb25zdCByZWNlbnRTb25ncyA9IGhpc3RvcnlEYXRhXG4gICAgICAgIC5maWx0ZXIoaXRlbSA9PiBpdGVtLnNvbmdzKSAvLyBFbnN1cmUgc29uZyBkYXRhIGV4aXN0c1xuICAgICAgICAubWFwKGl0ZW0gPT4ge1xuICAgICAgICAgIGNvbnN0IHNvbmdPYmogPSBBcnJheS5pc0FycmF5KGl0ZW0uc29uZ3MpID8gaXRlbS5zb25nc1swXSA6IGl0ZW0uc29uZ3M7XG4gICAgICAgICAgcmV0dXJuIGNvbnZlcnREYXRhYmFzZVNvbmcoc29uZ09iaiwgdXNlckxpa2VkU29uZ3MuaGFzKGl0ZW0uc29uZ19pZCkpO1xuICAgICAgICB9KTtcblxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhyZWNlbnRTb25ncylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcmVjZW50bHkgcGxheWVkIHNvbmdzOicsIGVycm9yKVxuICAgICAgc2V0UmVjZW50bHlQbGF5ZWRTb25ncyhbXSlcbiAgICB9XG4gIH1cblxuICAvLyBGZXRjaCB1c2VyIHBsYXlsaXN0c1xuICBjb25zdCBmZXRjaFBsYXlsaXN0cyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoIXVzZXIpIHtcbiAgICAgIHNldFBsYXlsaXN0cyhbXSlcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGE6IHBsYXlsaXN0c0RhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnNlbGVjdChgXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBwbGF5bGlzdF9zb25ncyAoXG4gICAgICAgICAgICBzb25ncyAoKilcbiAgICAgICAgICApXG4gICAgICAgIGApXG4gICAgICAgIC5lcSgndXNlcl9pZCcsIHVzZXIuaWQpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgY29uc3QgY29udmVydGVkUGxheWxpc3RzOiBQbGF5bGlzdFtdID0gcGxheWxpc3RzRGF0YT8ubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgY29uc3QgcGxheWxpc3RTb25ncyA9IHBsYXlsaXN0LnBsYXlsaXN0X3NvbmdzPy5tYXAoKHBzOiBhbnkpID0+IFxuICAgICAgICAgIGNvbnZlcnREYXRhYmFzZVNvbmcocHMuc29uZ3MsIGxpa2VkU29uZ3MuaGFzKHBzLnNvbmdzLmZpbGVfaWQpKVxuICAgICAgICApIHx8IFtdXG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBpZDogcGxheWxpc3QuaWQudG9TdHJpbmcoKSxcbiAgICAgICAgICBuYW1lOiBwbGF5bGlzdC5uYW1lLFxuICAgICAgICAgIHNvbmdDb3VudDogcGxheWxpc3RTb25ncy5sZW5ndGgsXG4gICAgICAgICAgaW1hZ2U6IHBsYXlsaXN0U29uZ3NbMF0/LmltYWdlIHx8ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCcsXG4gICAgICAgICAgc29uZ3M6IHBsYXlsaXN0U29uZ3NcbiAgICAgICAgfVxuICAgICAgfSkgfHwgW11cblxuICAgICAgc2V0UGxheWxpc3RzKGNvbnZlcnRlZFBsYXlsaXN0cylcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZmV0Y2hpbmcgcGxheWxpc3RzOicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIFRvZ2dsZSBsaWtlIHNvbmdcbiAgY29uc3QgdG9nZ2xlTGlrZSA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICBpZiAoIXVzZXIpIHJldHVybjtcblxuICBjb25zdCBzb25nRmlsZUlkID0gcGFyc2VJbnQoc29uZ0lkKTtcbiAgY29uc3QgaXNDdXJyZW50bHlMaWtlZCA9IGxpa2VkU29uZ3MuaGFzKHNvbmdGaWxlSWQpO1xuXG4gIHRyeSB7XG4gICAgaWYgKGlzQ3VycmVudGx5TGlrZWQpIHtcbiAgICAgIC8vIFJlbW92ZSBmcm9tIGxpa2VkX3NvbmdzXG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgnbGlrZWRfc29uZ3MnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCd1c2VyX2lkJywgdXNlci5pZClcbiAgICAgICAgLmVxKCdzb25nX2lkJywgc29uZ0ZpbGVJZCk7XG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3I7XG5cbiAgICAgIC8vIERlY3JlbWVudCBsaWtlc1xuICAgICAgYXdhaXQgc3VwYWJhc2UucnBjKCdkZWNyZW1lbnRfc29uZ19saWtlcycsIHsgc29uZ19maWxlX2lkOiBzb25nRmlsZUlkIH0pO1xuXG4gICAgICBzZXRMaWtlZFNvbmdzKHByZXYgPT4ge1xuICAgICAgICBjb25zdCBuZXdTZXQgPSBuZXcgU2V0KHByZXYpO1xuICAgICAgICBuZXdTZXQuZGVsZXRlKHNvbmdGaWxlSWQpO1xuICAgICAgICByZXR1cm4gbmV3U2V0O1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEFkZCB0byBsaWtlZF9zb25nc1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ2xpa2VkX3NvbmdzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICBzb25nX2lkOiBzb25nRmlsZUlkLFxuICAgICAgICB9KTtcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcblxuICAgICAgLy8gSW5jcmVtZW50IGxpa2VzXG4gICAgICBhd2FpdCBzdXBhYmFzZS5ycGMoJ2luY3JlbWVudF9zb25nX2xpa2VzJywgeyBzb25nX2ZpbGVfaWQ6IHNvbmdGaWxlSWQgfSk7XG5cbiAgICAgIHNldExpa2VkU29uZ3MocHJldiA9PiBuZXcgU2V0KHByZXYpLmFkZChzb25nRmlsZUlkKSk7XG4gICAgfVxuXG4gICAgLy8gVXBkYXRlIHNvbmdzIHN0YXRlXG4gICAgLy8gVXBkYXRlIHNvbmdzIHN0YXRlXG5zZXRTb25ncyhwcmV2U29uZ3MgPT5cbiAgcHJldlNvbmdzLm1hcChzb25nID0+XG4gICAgc29uZy5pZCA9PT0gc29uZ0lkXG4gICAgICA/IHtcbiAgICAgICAgICAuLi5zb25nLFxuICAgICAgICAgIGlzTGlrZWQ6ICFpc0N1cnJlbnRseUxpa2VkLFxuICAgICAgICAgIGxpa2VzOiBzb25nLmxpa2VzICsgKGlzQ3VycmVudGx5TGlrZWQgPyAtMSA6IDEpLFxuICAgICAgICB9XG4gICAgICA6IHNvbmdcbiAgKVxuKTtcblxuXG4gICAgLy8gVXBkYXRlIHBsYXlsaXN0cyBzdGF0ZVxuICAgIHNldFBsYXlsaXN0cyhwcmV2UGxheWxpc3RzID0+XG4gICAgICBwcmV2UGxheWxpc3RzLm1hcChwbGF5bGlzdCA9PiAoe1xuICAgICAgICAuLi5wbGF5bGlzdCxcbiAgICAgICAgc29uZ3M6IHBsYXlsaXN0LnNvbmdzLm1hcChzb25nID0+XG4gICAgICAgICAgc29uZy5pZCA9PT0gc29uZ0lkXG4gICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAuLi5zb25nLFxuICAgICAgICAgICAgICAgIGlzTGlrZWQ6ICFpc0N1cnJlbnRseUxpa2VkLFxuICAgICAgICAgICAgICAgIGxpa2VzOiBzb25nLmxpa2VzICsgKGlzQ3VycmVudGx5TGlrZWQgPyAtMSA6IDEpLFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICA6IHNvbmdcbiAgICAgICAgKSxcbiAgICAgIH0pKVxuICAgICk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgdG9nZ2xpbmcgbGlrZTonLCBlcnJvcik7XG4gIH1cbn07XG5cblxuICAvLyBDcmVhdGUgcGxheWxpc3RcbiAgY29uc3QgY3JlYXRlUGxheWxpc3QgPSBhc3luYyAobmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLmluc2VydCh7XG4gICAgICAgICAgdXNlcl9pZDogdXNlci5pZCxcbiAgICAgICAgICBuYW1lXG4gICAgICAgIH0pXG4gICAgICAgIC5zZWxlY3QoKVxuICAgICAgICAuc2luZ2xlKClcblxuICAgICAgaWYgKGVycm9yKSB0aHJvdyBlcnJvclxuXG4gICAgICBjb25zdCBuZXdQbGF5bGlzdDogUGxheWxpc3QgPSB7XG4gICAgICAgIGlkOiBkYXRhLmlkLnRvU3RyaW5nKCksXG4gICAgICAgIG5hbWU6IGRhdGEubmFtZSxcbiAgICAgICAgc29uZ0NvdW50OiAwLFxuICAgICAgICBpbWFnZTogJ2h0dHBzOi8vaW1hZ2VzLnBleGVscy5jb20vcGhvdG9zLzE3NjMwNzUvcGV4ZWxzLXBob3RvLTE3NjMwNzUuanBlZz9hdXRvPWNvbXByZXNzJmNzPXRpbnlzcmdiJnc9MzAwJyxcbiAgICAgICAgc29uZ3M6IFtdXG4gICAgICB9XG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFsuLi5wcmV2LCBuZXdQbGF5bGlzdF0pXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGNyZWF0aW5nIHBsYXlsaXN0OicsIGVycm9yKVxuICAgIH1cbiAgfVxuXG4gIC8vIERlbGV0ZSBwbGF5bGlzdFxuICBjb25zdCBkZWxldGVQbGF5bGlzdCA9IGFzeW5jIChwbGF5bGlzdElkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdHMnKVxuICAgICAgICAuZGVsZXRlKClcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IHByZXYuZmlsdGVyKHBsYXlsaXN0ID0+IHBsYXlsaXN0LmlkICE9PSBwbGF5bGlzdElkKSlcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgZGVsZXRpbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVuYW1lIHBsYXlsaXN0XG4gIGNvbnN0IHJlbmFtZVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgbmV3TmFtZTogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3RzJylcbiAgICAgICAgLnVwZGF0ZSh7IG5hbWU6IG5ld05hbWUgfSlcbiAgICAgICAgLmVxKCdpZCcsIHBhcnNlSW50KHBsYXlsaXN0SWQpKVxuICAgICAgICAuZXEoJ3VzZXJfaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG5cbiAgICAgIHNldFBsYXlsaXN0cyhwcmV2ID0+IFxuICAgICAgICBwcmV2Lm1hcChwbGF5bGlzdCA9PiBcbiAgICAgICAgICBwbGF5bGlzdC5pZCA9PT0gcGxheWxpc3RJZCBcbiAgICAgICAgICAgID8geyAuLi5wbGF5bGlzdCwgbmFtZTogbmV3TmFtZSB9XG4gICAgICAgICAgICA6IHBsYXlsaXN0XG4gICAgICAgIClcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgcmVuYW1pbmcgcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHNvbmcgdG8gcGxheWxpc3RcbiAgY29uc3QgYWRkU29uZ1RvUGxheWxpc3QgPSBhc3luYyAocGxheWxpc3RJZDogc3RyaW5nLCBzb25nOiBTb25nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIHRyeSB7XG4gICAgICBjb25zdCB7IGVycm9yIH0gPSBhd2FpdCBzdXBhYmFzZVxuICAgICAgICAuZnJvbSgncGxheWxpc3Rfc29uZ3MnKVxuICAgICAgICAuaW5zZXJ0KHtcbiAgICAgICAgICBwbGF5bGlzdF9pZDogcGFyc2VJbnQocGxheWxpc3RJZCksXG4gICAgICAgICAgc29uZ19pZDogc29uZy5maWxlX2lkXG4gICAgICAgIH0pXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgICBpZiAocGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNvbmdFeGlzdHMgPSBwbGF5bGlzdC5zb25ncy5zb21lKHMgPT4gcy5pZCA9PT0gc29uZy5pZClcbiAgICAgICAgICAgIGlmICghc29uZ0V4aXN0cykge1xuICAgICAgICAgICAgICBjb25zdCB1cGRhdGVkU29uZ3MgPSBbLi4ucGxheWxpc3Quc29uZ3MsIHNvbmddXG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgLi4ucGxheWxpc3QsXG4gICAgICAgICAgICAgICAgc29uZ3M6IHVwZGF0ZWRTb25ncyxcbiAgICAgICAgICAgICAgICBzb25nQ291bnQ6IHVwZGF0ZWRTb25ncy5sZW5ndGgsXG4gICAgICAgICAgICAgICAgaW1hZ2U6IHVwZGF0ZWRTb25nc1swXT8uaW1hZ2UgfHwgcGxheWxpc3QuaW1hZ2VcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gcGxheWxpc3RcbiAgICAgICAgfSlcbiAgICAgIClcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29uc29sZS5lcnJvcignRXJyb3IgYWRkaW5nIHNvbmcgdG8gcGxheWxpc3Q6JywgZXJyb3IpXG4gICAgfVxuICB9XG5cbiAgLy8gUmVtb3ZlIHNvbmcgZnJvbSBwbGF5bGlzdFxuICBjb25zdCByZW1vdmVTb25nRnJvbVBsYXlsaXN0ID0gYXN5bmMgKHBsYXlsaXN0SWQ6IHN0cmluZywgc29uZ0lkOiBzdHJpbmcpID0+IHtcbiAgICBpZiAoIXVzZXIpIHJldHVyblxuXG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlXG4gICAgICAgIC5mcm9tKCdwbGF5bGlzdF9zb25ncycpXG4gICAgICAgIC5kZWxldGUoKVxuICAgICAgICAuZXEoJ3BsYXlsaXN0X2lkJywgcGFyc2VJbnQocGxheWxpc3RJZCkpXG4gICAgICAgIC5lcSgnc29uZ19pZCcsIHBhcnNlSW50KHNvbmdJZCkpXG5cbiAgICAgIGlmIChlcnJvcikgdGhyb3cgZXJyb3JcblxuICAgICAgc2V0UGxheWxpc3RzKHByZXYgPT4gXG4gICAgICAgIHByZXYubWFwKHBsYXlsaXN0ID0+IHtcbiAgICAgICAgICBpZiAocGxheWxpc3QuaWQgPT09IHBsYXlsaXN0SWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRTb25ncyA9IHBsYXlsaXN0LnNvbmdzLmZpbHRlcihzb25nID0+IHNvbmcuaWQgIT09IHNvbmdJZClcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgIC4uLnBsYXlsaXN0LFxuICAgICAgICAgICAgICBzb25nczogdXBkYXRlZFNvbmdzLFxuICAgICAgICAgICAgICBzb25nQ291bnQ6IHVwZGF0ZWRTb25ncy5sZW5ndGgsXG4gICAgICAgICAgICAgIGltYWdlOiB1cGRhdGVkU29uZ3NbMF0/LmltYWdlIHx8ICdodHRwczovL2ltYWdlcy5wZXhlbHMuY29tL3Bob3Rvcy8xNzYzMDc1L3BleGVscy1waG90by0xNzYzMDc1LmpwZWc/YXV0bz1jb21wcmVzcyZjcz10aW55c3JnYiZ3PTMwMCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHBsYXlsaXN0XG4gICAgICAgIH0pXG4gICAgICApXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlbW92aW5nIHNvbmcgZnJvbSBwbGF5bGlzdDonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBVcGRhdGUgbGFzdCBzb25nIGluIHVzZXIgcHJvZmlsZVxuICBjb25zdCB1cGRhdGVMYXN0U29uZyA9IGFzeW5jIChzb25nSWQ6IHN0cmluZykgPT4ge1xuICAgIGlmICghdXNlcikgcmV0dXJuXG5cbiAgICB0cnkge1xuICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2VcbiAgICAgICAgLmZyb20oJ3VzZXJzJylcbiAgICAgICAgLnVwZGF0ZSh7IGxhc3Rfc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pXG4gICAgICAgIC5lcSgnaWQnLCB1c2VyLmlkKVxuXG4gICAgICBpZiAoZXJyb3IpIHRocm93IGVycm9yXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHVwZGF0aW5nIGxhc3Qgc29uZzonLCBlcnJvcilcbiAgICB9XG4gIH1cblxuICAvLyBSZWNvcmQgbGlzdGVuaW5nIGhpc3Rvcnkgd2l0aCBwcm9wZXIgdGltZSB0cmFja2luZ1xuICBjb25zdCByZWNvcmRMaXN0ZW5pbmdIaXN0b3J5ID0gYXN5bmMgKHNvbmdJZDogc3RyaW5nKSA9PiB7XG4gICAgaWYgKCF1c2VyKSByZXR1cm5cblxuICAgIC8vIElmIHRoZXJlJ3MgYSBwcmV2aW91cyBzb25nIHBsYXlpbmcsIHJlY29yZCBpdHMgbGlzdGVuaW5nIHRpbWVcbiAgICAgIGlmIChjdXJyZW50U29uZ1JlZi5jdXJyZW50ICYmIGN1cnJlbnRTb25nU3RhcnRUaW1lKSB7XG4gICAgY29uc3QgZW5kVGltZSA9IG5ldyBEYXRlKCk7XG4gICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApO1xuXG4gICAgaWYgKG1pbnV0ZXNMaXN0ZW5lZCA+IDAuMSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWludXRlcyA9IE1hdGgucm91bmQobWludXRlc0xpc3RlbmVkICogMTAwKSAvIDEwMDtcbiAgICAgICAgY29uc3QgeyBlcnJvciB9ID0gYXdhaXQgc3VwYWJhc2UucnBjKCd1cHNlcnRfaGlzdG9yeV9taW51dGVzJywge1xuICAgICAgICAgIHVzZXJfdXVpZDogdXNlci5pZCxcbiAgICAgICAgICBzb25nX2ZpbGVfaWQ6IHBhcnNlSW50KGN1cnJlbnRTb25nUmVmLmN1cnJlbnQpLFxuICAgICAgICAgIG1pbnV0ZXM6IG1pbnV0ZXMsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgIGNvbnNvbGUuZXJyb3IoJ+KdjCBFcnJvciByZWNvcmRpbmcgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb25zb2xlLmxvZyhg4pyFIEhpc3RvcnkgdXBkYXRlZDogKyR7bWludXRlc30gbWlucyBmb3Igc29uZyAke2N1cnJlbnRTb25nUmVmLmN1cnJlbnR9YCk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHJlY29yZGluZyBwcmV2aW91cyBzb25nIGhpc3Rvcnk6JywgZXJyb3IpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG5cbiAgICAvLyBTZXQgbmV3IHNvbmcgYXMgY3VycmVudFxuICAgIGN1cnJlbnRTb25nUmVmLmN1cnJlbnQgPSBzb25nSWRcbiAgICBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZShuZXcgRGF0ZSgpKVxuICAgIFxuICAgIC8vIFVwZGF0ZSBsYXN0IHNvbmcgaW4gdXNlciBwcm9maWxlXG4gICAgYXdhaXQgdXBkYXRlTGFzdFNvbmcoc29uZ0lkKVxudHJ5IHtcbiAgYXdhaXQgc3VwYWJhc2UucnBjKCdpbmNyZW1lbnRfc29uZ192aWV3cycsIHsgc29uZ19maWxlX2lkOiBwYXJzZUludChzb25nSWQpIH0pO1xufSBjYXRjaCAoZXJyb3IpIHtcbiAgY29uc29sZS5lcnJvcignRXJyb3IgaW5jcmVtZW50aW5nIHNvbmcgdmlld3M6JywgZXJyb3IpO1xufVxuXG4gIH1cblxuICAvLyBTdG9wIGN1cnJlbnQgc29uZyB0cmFja2luZyAod2hlbiBwbGF5ZXIgaXMgY2xvc2VkKVxuICBjb25zdCBzdG9wQ3VycmVudFNvbmdUcmFja2luZyA9IGFzeW5jICgpID0+IHtcbiAgICBpZiAoY3VycmVudFNvbmdSZWYuY3VycmVudCAmJiBjdXJyZW50U29uZ1N0YXJ0VGltZSAmJiB1c2VyKSB7XG4gICAgICBjb25zdCBlbmRUaW1lID0gbmV3IERhdGUoKVxuICAgICAgY29uc3QgbWludXRlc0xpc3RlbmVkID0gKGVuZFRpbWUuZ2V0VGltZSgpIC0gY3VycmVudFNvbmdTdGFydFRpbWUuZ2V0VGltZSgpKSAvICgxMDAwICogNjApXG4gICAgICBcbiAgICAgIGlmIChtaW51dGVzTGlzdGVuZWQgPiAwLjEpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBtaW51dGVzID0gTWF0aC5yb3VuZChtaW51dGVzTGlzdGVuZWQgKiAxMDApIC8gMTAwO1xuICAgIGNvbnN0IHsgZXJyb3IgfSA9IGF3YWl0IHN1cGFiYXNlLnJwYygndXBzZXJ0X2hpc3RvcnlfbWludXRlcycsIHtcbiAgICAgIHVzZXJfdXVpZDogdXNlci5pZCxcbiAgICAgIHNvbmdfZmlsZV9pZDogcGFyc2VJbnQoY3VycmVudFNvbmdSZWYuY3VycmVudCksXG4gICAgICBtaW51dGVzOiBtaW51dGVzLFxuICAgIH0pO1xuXG4gICAgaWYgKGVycm9yKSB7XG4gICAgICBjb25zb2xlLmVycm9yKCfinYwgRXJyb3IgcmVjb3JkaW5nIHNvbmcgaGlzdG9yeSBvbiBzdG9wOicsIGVycm9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc29sZS5sb2coYPCfm5EgSGlzdG9yeSB1cGRhdGVkIG9uIHN0b3A6ICske21pbnV0ZXN9IG1pbnMgZm9yIHNvbmcgJHtjdXJyZW50U29uZ1JlZi5jdXJyZW50fWApO1xuICAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciByZWNvcmRpbmcgZmluYWwgc29uZyBoaXN0b3J5OicsIGVycm9yKTtcbiAgfVxufVxuXG4gICAgfVxuXG4gICAgY3VycmVudFNvbmdSZWYuY3VycmVudCA9IG51bGxcbiAgICBzZXRDdXJyZW50U29uZ1N0YXJ0VGltZShudWxsKVxuICB9XG5cbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBjb25zdCBsb2FkRGF0YSA9IGFzeW5jICgpID0+IHtcbiAgICAgIGlmICghdXNlcikge1xuICAgICAgICAvLyBSZXNldCBkYXRhIHdoZW4gdXNlciBsb2dzIG91dFxuICAgICAgICBzb25nc0NhY2hlLmN1cnJlbnQgPSBudWxsXG4gICAgICAgIGxpa2VkU29uZ3NDYWNoZS5jdXJyZW50ID0gbnVsbFxuICAgICAgICBzZXRTb25ncyhbXSlcbiAgICAgICAgc2V0UGVyc29uYWxpemVkU29uZ3MoW10pXG4gICAgICAgIHNldFRyZW5kaW5nU29uZ3MoW10pXG4gICAgICAgIHNldFBsYXlsaXN0cyhbXSlcbiAgICAgICAgc2V0TGlrZWRTb25ncyhuZXcgU2V0KCkpXG4gICAgICAgIHNldFJlY2VudGx5UGxheWVkU29uZ3MoW10pXG4gICAgICAgIHNldExhc3RQbGF5ZWRTb25nKG51bGwpXG4gICAgICAgIHNldExvYWRpbmcoZmFsc2UpXG4gICAgICAgIHJldHVyblxuICAgICAgfVxuXG4gICAgICB0cnkge1xuICAgICAgICBzZXRMb2FkaW5nKHRydWUpXG4gICAgICAgIGF3YWl0IFByb21pc2UuYWxsKFtmZXRjaFNvbmdzKCksIGZldGNoUGxheWxpc3RzKCksIGZldGNoUmVjZW50bHlQbGF5ZWQoKV0pXG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdFcnJvciBsb2FkaW5nIGRhdGE6JywgZXJyb3IpXG4gICAgICAgIC8vIFJlc2V0IGRhdGEgb24gZXJyb3JcbiAgICAgICAgc2V0U29uZ3MoW10pXG4gICAgICAgIHNldFBlcnNvbmFsaXplZFNvbmdzKFtdKVxuICAgICAgICBzZXRUcmVuZGluZ1NvbmdzKFtdKVxuICAgICAgICBzZXRQbGF5bGlzdHMoW10pXG4gICAgICAgIHNldExpa2VkU29uZ3MobmV3IFNldCgpKVxuICAgICAgICBzZXRSZWNlbnRseVBsYXllZFNvbmdzKFtdKVxuICAgICAgICBzZXRMYXN0UGxheWVkU29uZyhudWxsKVxuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgc2V0TG9hZGluZyhmYWxzZSlcbiAgICAgIH1cbiAgICB9XG5cbiAgICBsb2FkRGF0YSgpXG4gIH0sIFt1c2VyXSlcblxuICByZXR1cm4ge1xuICAgIHNvbmdzLCAvLyBhbGwgc29uZ3NcbiAgICBwZXJzb25hbGl6ZWRTb25ncywgLy8gc21hcnQgc29ydGVkLCBmaWx0ZXJlZCwgYW5kIGhpc3RvcnktZXhjbHVkZWQgbGlzdFxuICAgIHRyZW5kaW5nU29uZ3MsIC8vIHRvcCAxNSB0cmVuZGluZyBieSB2aWV3cytsaWtlc1xuICAgIHBsYXlsaXN0cyxcbiAgICBsaWtlZFNvbmdzOiBzb25ncy5maWx0ZXIoc29uZyA9PiBzb25nLmlzTGlrZWQpLFxuICAgIHJlY2VudGx5UGxheWVkU29uZ3MsXG4gICAgbGFzdFBsYXllZFNvbmcsXG4gICAgbG9hZGluZyxcbiAgICB0b2dnbGVMaWtlLFxuICAgIGNyZWF0ZVBsYXlsaXN0LFxuICAgIGRlbGV0ZVBsYXlsaXN0LFxuICAgIHJlbmFtZVBsYXlsaXN0LFxuICAgIGFkZFNvbmdUb1BsYXlsaXN0LFxuICAgIHJlbW92ZVNvbmdGcm9tUGxheWxpc3QsXG4gICAgcmVjb3JkTGlzdGVuaW5nSGlzdG9yeSxcbiAgICBzdG9wQ3VycmVudFNvbmdUcmFja2luZyxcbiAgICByZWZyZXNoRGF0YTogKCkgPT4ge1xuICAgICAgZmV0Y2hTb25ncygpXG4gICAgICBmZXRjaFBsYXlsaXN0cygpXG4gICAgICBmZXRjaFJlY2VudGx5UGxheWVkKClcbiAgICB9LFxuICAgIGdldFBlcnNvbmFsaXplZFNvbmdzLFxuICAgIGdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3NcbiAgfVxufSJdLCJuYW1lcyI6WyJzdXBhYmFzZSIsInVzZUVmZmVjdCIsInVzZVJlZiIsInVzZVN0YXRlIiwidXNlU3VwYWJhc2VEYXRhIiwidXNlciIsInNvbmdzQ2FjaGUiLCJsaWtlZFNvbmdzQ2FjaGUiLCJzb25ncyIsInNldFNvbmdzIiwicGVyc29uYWxpemVkU29uZ3MiLCJzZXRQZXJzb25hbGl6ZWRTb25ncyIsInRyZW5kaW5nU29uZ3MiLCJzZXRUcmVuZGluZ1NvbmdzIiwicGxheWxpc3RzIiwic2V0UGxheWxpc3RzIiwibGlrZWRTb25ncyIsInNldExpa2VkU29uZ3MiLCJTZXQiLCJsYXN0UGxheWVkU29uZyIsInNldExhc3RQbGF5ZWRTb25nIiwicmVjZW50bHlQbGF5ZWRTb25ncyIsInNldFJlY2VudGx5UGxheWVkU29uZ3MiLCJsb2FkaW5nIiwic2V0TG9hZGluZyIsImN1cnJlbnRTb25nU3RhcnRUaW1lIiwic2V0Q3VycmVudFNvbmdTdGFydFRpbWUiLCJjdXJyZW50U29uZ1JlZiIsImdldFNtYXJ0UGVyc29uYWxpemVkU29uZ3MiLCJ1c2VySWQiLCJsaXN0ZW5lZFNvbmdzSW5CYXRjaCIsImV4Y2x1ZGVTb25ncyIsImNvbnNvbGUiLCJsb2ciLCJtYXAiLCJzIiwibmFtZSIsImxlbmd0aCIsInByZWZlcnJlZFRhZ3MiLCJwcmVmZXJyZWRBcnRpc3RzIiwiZm9yRWFjaCIsInNvbmciLCJ0YWdzIiwidGFnIiwiYWRkIiwidG9Mb3dlckNhc2UiLCJhcnRpc3QiLCJBcnJheSIsImZyb20iLCJzb25nc0RhdGEiLCJjdXJyZW50IiwiZGF0YSIsImVycm9yIiwic2VsZWN0Iiwid2FybiIsInVzZXJMaWtlZFNvbmdzIiwibGlrZWREYXRhIiwiZXEiLCJpdGVtIiwic29uZ19pZCIsImxhbmd1YWdlRmlsdGVyIiwibGFuZ3VhZ2UiLCJhdmFpbGFibGVTb25ncyIsImZpbHRlciIsImhhcyIsImZpbGVfaWQiLCJ0b1N0cmluZyIsInNjb3JlZFNvbmdzIiwic2NvcmUiLCJzb25nVGFncyIsIm1hdGNoaW5nVGFncyIsImxpc3RlbmVkTGFuZ3VhZ2VzIiwiaW5jbHVkZXMiLCJNYXRoIiwibGlrZXMiLCJ2aWV3cyIsInJhbmRvbSIsImNvbnZlcnREYXRhYmFzZVNvbmciLCJyZWNvbW1lbmRhdGlvbnMiLCJzb3J0IiwiYSIsImIiLCJzbGljZSIsImVudHJ5IiwiZGJTb25nIiwiaXNMaWtlZCIsImltZ19pZCIsImlkIiwiaW1hZ2UiLCJmZXRjaFNvbmdzIiwib3JkZXIiLCJhc2NlbmRpbmciLCJoaXN0b3J5RGF0YSIsImhpc3RvcnlFcnJvciIsInRvcEhpc3RvcnkiLCJoIiwidGFnQ291bnQiLCJhcnRpc3RDb3VudCIsInNvbmdPYmoiLCJpc0FycmF5IiwidCIsImNvbW1vblRhZ3MiLCJPYmplY3QiLCJlbnRyaWVzIiwiY29tbW9uQXJ0aXN0cyIsImhpc3RvcnlTb25nSWRzIiwiY29udmVydGVkU29uZ3MiLCJmaWx0ZXJlZFNvbmdzIiwicGVyc29uYWxpemVkU29ydGVkIiwidHJlbmRpbmciLCJ1c2VyRGF0YSIsInNpbmdsZSIsImxhc3Rfc29uZ19maWxlX2lkIiwibGFzdFNvbmciLCJmaW5kIiwiZ2V0UGVyc29uYWxpemVkU29uZ3MiLCJjdXJyZW50U29uZyIsImxpc3RlbmVkU29uZ3MiLCJzaXplIiwiaGlzdG9yeU1hcCIsIk1hcCIsInNldCIsIm1pbnV0ZXNfbGlzdGVuZWQiLCJsaXN0ZW5lZE1pbnV0ZXMiLCJnZXQiLCJtaW4iLCJmZXRjaFJlY2VudGx5UGxheWVkIiwibGltaXQiLCJyZWNlbnRTb25ncyIsImZldGNoUGxheWxpc3RzIiwicGxheWxpc3RzRGF0YSIsImNvbnZlcnRlZFBsYXlsaXN0cyIsInBsYXlsaXN0IiwicGxheWxpc3RTb25ncyIsInBsYXlsaXN0X3NvbmdzIiwicHMiLCJzb25nQ291bnQiLCJ0b2dnbGVMaWtlIiwic29uZ0lkIiwic29uZ0ZpbGVJZCIsInBhcnNlSW50IiwiaXNDdXJyZW50bHlMaWtlZCIsImRlbGV0ZSIsInJwYyIsInNvbmdfZmlsZV9pZCIsInByZXYiLCJuZXdTZXQiLCJpbnNlcnQiLCJ1c2VyX2lkIiwicHJldlNvbmdzIiwicHJldlBsYXlsaXN0cyIsImNyZWF0ZVBsYXlsaXN0IiwibmV3UGxheWxpc3QiLCJkZWxldGVQbGF5bGlzdCIsInBsYXlsaXN0SWQiLCJyZW5hbWVQbGF5bGlzdCIsIm5ld05hbWUiLCJ1cGRhdGUiLCJhZGRTb25nVG9QbGF5bGlzdCIsInBsYXlsaXN0X2lkIiwic29uZ0V4aXN0cyIsInNvbWUiLCJ1cGRhdGVkU29uZ3MiLCJyZW1vdmVTb25nRnJvbVBsYXlsaXN0IiwidXBkYXRlTGFzdFNvbmciLCJyZWNvcmRMaXN0ZW5pbmdIaXN0b3J5IiwiZW5kVGltZSIsIkRhdGUiLCJtaW51dGVzTGlzdGVuZWQiLCJnZXRUaW1lIiwibWludXRlcyIsInJvdW5kIiwidXNlcl91dWlkIiwic3RvcEN1cnJlbnRTb25nVHJhY2tpbmciLCJsb2FkRGF0YSIsIlByb21pc2UiLCJhbGwiLCJyZWZyZXNoRGF0YSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./hooks/useSupabaseData.ts\n"));

/***/ })

});